# Copyright 2016 Xored Software, Inc.

type
  FParticleAnimTrailEmitterInstance* {.importcpp, header: "ParticleEmitterInstances.h".}= object
    # AWARE: not interfaced

# ParticleSystem.h
type
  ParticleSystemLODMethod* {.importcpp, header: "Particles/ParticleSystem.h", size: sizeof(cint).} = enum
    ## ParticleSystemLODMethod
    PARTICLESYSTEMLODMETHOD_Automatic,
      ## Automatically set the LOD level, checking every LODDistanceCheckTime seconds.
    PARTICLESYSTEMLODMETHOD_DirectSet,
      ## LOD level is directly set by the game code.
    PARTICLESYSTEMLODMETHOD_ActivateAutomatic
      ## LOD level is determined at Activation time, then left alone unless directly set by game code.

# ParticleHelper.h
type
  FParticleDynamicData* {.importcpp, header: "Particles/ParticleHelper.h".} = object
    # AWARE: not interfaced
  FParticleSystemSceneProxy* {.importcpp, header: "Particles/ParticleHelper.h".} = object
    # AWARE: not interfaced

# ParticleEmitterInstances.h
type
  FParticleEmitterInstance* {.importcpp, header: "ParticleEmitterInstances.h".} = object
    # AWARE: not interfaced

# FXSystem
type
  FFXSystemInterface* {.importcpp, header: "FXSystem.h".} = object
    # AWARE: not interfaced

wclass(UParticleModuleEventSendToGame of UObject, header: "Particles/Event/ParticleModuleEventSendToGame.h"):
  method doEvent(inCollideDirection: FVector, inHitLocation: FVector, inHitNormal: FVector, inBoneName: FName)
    ## This is our function to allow subclasses to "do the event action"

type
  TrailEmitterArray* = TArray[ptr FParticleAnimTrailEmitterInstance]
    ## Array of trail emitters.
  EForceAsyncWorkCompletion* {.importcpp, header: "Particles/ParticleSystemComponent.h", pure, size: sizeof(cint).} = enum
    STALL, ENSURE_AND_STALL, SILENT ## this would only be appropriate for editor only or other unusual things that we never see in game

  EParticleSysParamType* {.importcpp, header: "Particles/ParticleSystemComponent.h".} = enum
    ## UENUM(BlueprintType)
    ## Enum for specifying type of a name instance parameter.
    PSPT_None,
    PSPT_Scalar,
    PSPT_ScalarRand,
    PSPT_Vector,
    PSPT_VectorRand,
    PSPT_Color,
    PSPT_Actor,
    PSPT_Material,
    PSPT_MAX

  ParticleReplayState* {.importcpp, header: "Particles/ParticleSystemComponent.h".} = enum
    ## Particle system replay state
    PRS_Disabled,
      ## Replay system is disabled.  Particles are simulated and rendered normally.
    PRS_Capturing,
      ## Capture all particle data to the clip specified by ReplayClipIDNumber.  The frame to capture
      ## must be specified using the ReplayFrameIndex
    PRS_Replaying,
      ## Replay captured particle state from the clip specified by ReplayClipIDNumber.  The frame to play
      ## must be specified using the ReplayFrameIndex
    PRS_MAX

  EParticleEventType* {.importcpp, header: "Particles/ParticleSystemComponent.h".} = enum
    ## Event type
    EPET_Any,
      ## Any - allow any event
    EPET_Spawn,
      ## Spawn - a particle spawn event
    EPET_Death,
      ## Death - a particle death event
    EPET_Collision,
      ## Collision - a particle collision event
    EPET_Burst,
      ## Burst - a particle burst event
    EPET_Blueprint,
      ## Blueprint - an event generated by level script
    EPET_MAX,

  FParticleSysParam* {.importcpp, header: "Particles/ParticleSystemComponent.h".} = object
    ## Struct used for a particular named instance parameter for this ParticleSystemComponent.

    name* {.importcpp: "Name".}: FName
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
      ## The name of the parameter

    paramType* {.importcpp: "ParamType".}: EParticleSysParamType
      ##	The type of parameters
      ##	PSPT_None       - There is no data type
      ##	PSPT_Scalar     - Use the scalar value
      ##	PSPT_ScalarRand - Select a scalar value in the range [Scalar_Low..Scalar)
      ##	PSPT_Vector     - Use the vector value
      ##	PSPT_VectorRand - Select a vector value in the range [Vector_Low..Vector)
      ##	PSPT_Color      - Use the color value
      ##	PSPT_Actor      - Use the actor value
      ##	PSPT_Material   - Use the material value
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    scalar {.importcpp: "Scalar".}: cfloat
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    scalar_Low {.importcpp: "Scalar_Low".}: cfloat
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    vector {.importcpp: "Vector".}: FVector
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    vector_Low {.importcpp: "Vector_Low".}: FVector
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    color {.importcpp: "Color".}: FColor
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    actor {.importcpp: "Actor".}: ptr AActor
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)
    material {.importcpp: "Material".}: ptr UMaterialInterface
      ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=ParticleSysParam)

  FParticleEventData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy, inheritable.} = object
    ## The base class for all particle event data.
    typ* {.importcpp: "Type".}: int32
      ## The type of event that was generated.
    eventName* {.importcpp: "EventName".}: FName
      ## The name of the event.
    emitterTime* {.importcpp: "EventName".}: cfloat
      ## The emitter time at the event.
    location* {.importcpp: "Location".}: FVector
      ## The location of the event.
    velocity* {.importcpp: "Velocity".}: FVector
      ## The velocity at the time of the event.
    eventData* {.importcpp: "EventData".}: TArray[ptr UParticleModuleEventSendToGame]
      ## Game specific event metadata

  FParticleExistingData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy.} = object of FParticleEventData
    ## Particle event data for particles that already existed at the time of the event
    particleTime* {.importcpp: "ParticleTime".}: cfloat
      ## How long the particle had been alive at the time of the event.
    direction* {.importcpp: "Direction".}: FVector
      ## The direction of the particle at the time of the event.

  FParticleEventSpawnData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy.} = object of FParticleEventData
    ## Spawn particle event data.
  FParticleEventDeathData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy.} = object of FParticleExistingData
    ## Killed particle event data.
  FParticleEventCollideData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy.} = object of FParticleExistingData
    ## Collision particle event data.
    normal* {.importcpp: "Normal".}: FVector
      ## Normal vector in coordinate system of the returner. Zero=none.
    time* {.importcpp: "Time".}: cfloat
      ## Time until hit, if line check.
    item* {.importcpp: "Item".}: int32
      ## Primitive data item which was hit, INDEX_NONE=none.
    boneName* {.importcpp: "BoneName".}: FName
      ## Name of bone we hit (for skeletal meshes).
  FParticleEventBurstData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy.} = object of FParticleEventData
    ## Particle burst event data.
    particleCount* {.importcpp: "ParticleCount".}: int32
  FParticleEventKismetData* {.importcpp, header: "Particles/ParticleSystemComponent.h", bycopy.} = object of FParticleEventData
    ## Kismet particle event data.

proc initFParticleSysParam(): FParticleSysParam {.importcpp: "FParticleSysParam(@)", header: "Particles/ParticleSystemComponent.h", constructor.}

proc initFParticleEventData(): FParticleEventData {.importcpp: "'0(@)", header: "Particles/ParticleSystemComponent.h", constructor.}

proc initFParticleExistingData(): FParticleExistingData {.importcpp: "FParticleExistingData(@)", header: "Particles/ParticleSystemComponent.h", constructor.}

proc initFParticleEventCollideData(): FParticleEventCollideData {.importcpp: "'0(@)", header: "Particles/ParticleSystemComponent.h", constructor.}

proc initFParticleEventBurstData(): FParticleEventBurstData {.importcpp: "'0(@)", header: "Particles/ParticleSystemComponent.h", constructor.}

# Called when the particle system is done
declareBuiltinDelegate(FOnSystemFinished, dkDynamicMulticast, "Particles/ParticleSystemComponent.h", pSystem: ptr UParticleSystemComponent)

declareBuiltinDelegate(FParticleSpawnSignature, dkDynamicMulticast, "Particles/Emitter.h", eventName:FName, emitterTime: float, location: FVector, velocity: FVector)
# Fires when a particle is spawned
# @param EventName - Custom event name for the Spawn Event.
# @param EmitterTime - The emitter time when the event occured.
# @param Location - Location at which the particle was spawned.
# @param Velocity - Initial velocity of the spawned particle.

declareBuiltinDelegate(FParticleBurstSignature, dkDynamicMulticast, "Particles/Emitter.h", eventName: FName, emitterTime: float, particleCount: int32)
# Fires when a particle system bursts
# @param EventName - Custom event name for the Burst Event
# @param EmitterTime - The emitter time when the event occured.
# @param ParticleCount - The number of particles spawned in the burst.

declareBuiltinDelegate(FParticleDeathSignature, dkDynamicMulticast, "Particles/Emitter.h", eventName: FName, emitterTime: float, particleTime: int32, location: FVector, velocity: FVector, direction: FVector)
# Fires when a particle dies
# @param EventName - Custom event name for the Death Event.
# @param EmitterTime - The emitter time when the event occured.
# @param ParticleTime - How long the particle had been alive at the time of the event.
# @param Location - Location the particle was at when it died.
# @param Velocity - Velocity of the particle when it died.
# @param Direction - Direction of the particle when it died.

declareBuiltinDelegate(FParticleCollisionSignature, dkDynamicMulticast, "Particles/Emitter.h", eventName: FName, emitterTime: float32, particleTime: int32, location: FVector, velocity: FVector, direction: FVector, normal: FVector, boneName: FName)
# Fires when a particle dies
# @param EventName - Custom event name for the Collision Event.
# @param EmitterTime - The emitter time when the event occured.
# @param ParticleTime - How long the particle had been alive at the time of the event.
# @param Location - Location of the collision.
# @param Velocity - Velocity of the particle at the point of collision.
# @param Direction - Direction of the particle at the point of collision.
# @param Normal - Normal to the surface with which collision occurred.
# @param BoneName- Name of the bone that the particle collided with. (Only valid if collision was with a Skeletal Mesh)

wclass(UParticleSystemComponent of UPrimitiveComponent, header: "Particles/ParticleSystemComponent.h", notypedef):
  var tmpl {.cppname: "Template".}: ptr UParticleSystem
    ## UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Particles)

  var emitterMaterials: TArray[ptr UMaterialInterface]
    ## UPROPERTY(transient, duplicatetransient)

  var skelMeshComponents: TArray[ptr USkeletalMeshComponent]
    ## 	The skeletal mesh components used with the socket location module.
    ## 	This is to prevent them from being garbage collected.
    ##
    ## UPROPERTY(transient, duplicatetransient)

  var bWasCompleted: bool

  var bSuppressSpawning: bool

  var bWasDeactivated: bool

  var bWasActive: bool
    ## True if this was active before being unregistered or otherwise reset, if so reactivate it

  var bResetOnDetach: bool
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Particles)

  var bUpdateOnDedicatedServer: bool
    ## whether to update the particle system on dedicated servers
    ## UPROPERTY()

  var bJustRegistered: bool
    ## Indicates that the component has not been ticked since being registered.

  var bHasBeenActivated: bool
    ## This flag will be set the first time the PSysComp is activated... used to prevent auto activated PSysComps from calling InitParticles twice on level load

  var bAllowRecycling: bool
    ## If true, this Particle System will be available for recycling after it has completed. Auto-destroyed systems cannot be recycled.
    ## Some systems (currently particle trail effects) can recycle components to avoid respawning them to play new effects.
    ## This is only an optimization and does not change particle system behavior, aside from not triggering normal component initialization events more than once.
    ##
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, AdvancedDisplay, Category=Particles)

  var bAutoManageAttachment: bool
    ## True if we should automatically attach to AutoAttachParent when activated, and detach from our parent when completed.
    ## This overrides any current attachment that may be present at the time of activation (deferring initial attachment until activation, if AutoAttachParent is null).
    ## When enabled, detachment occurs regardless of whether AutoAttachParent is assigned, and the relative transform from the time of activation is restored.
    ## This also disables attachment on dedicated servers, where we don't actually activate even if bAutoActivate is true.
    ## @see AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType
    ##
    ## UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Attachment)

  var instanceParameters: TArray[FParticleSysParam]
    ## 	Array holding name instance parameters for this ParticleSystemComponent.
    ## 	Parameters can be used in Cascade using DistributionFloat/VectorParticleParameters.
    ##
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Particles)

  var onParticleSpawn: FParticleSpawnSignature
    ## UPROPERTY(BlueprintAssignable)

  var onParticleBurst: FParticleBurstSignature
    ## UPROPERTY(BlueprintAssignable)

  var onParticleDeath: FParticleDeathSignature
    ## UPROPERTY(BlueprintAssignable)

  var onParticleCollide: FParticleCollisionSignature
    ## UPROPERTY(BlueprintAssignable)

  var oldPosition: FVector
    ## UPROPERTY()

  var partSysVelocity: FVector
    ## UPROPERTY()

  var warmupTime: cfloat
    ## UPROPERTY()

  var warmupTickRate: cfloat
    ## UPROPERTY()

  var bWarmingUp: bool
    ## UPROPERTY()

  var bAutoDestroy: bool

  var secondsBeforeInactive: cfloat
    ## Number of seconds of emitter not being rendered that need to pass before it
    ## no longer gets ticked/ becomes inactive.
    ##
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Particles)

  var maxTimeBeforeForceUpdateTransform: cfloat
    ## Time between forced UpdateTransforms for systems that use dynamically calculated bounds,
    ## Which is effectively how often the bounds are shrunk.
    ##
    ## UPROPERTY()

# when WITH_EDITORONLY_DATA:
  var editorDetailMode: int32
    ##
    ## Used for applying Cascade's detail mode setting to in-level particle systems
    ##
    ## UPROPERTY()
# endwhen

  var accumTickTime: cfloat

  var bOverrideLODMethod: bool
    ## indicates that the component's LODMethod overrides the Template's
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=LOD)

  var LODMethod: ParticleSystemLODMethod
    ## The method of LOD level determination to utilize for this particle system
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=LOD)

  var bSkipUpdateDynamicDataDuringTick: bool
    ## 	Flag indicating that dynamic updating of render data should NOT occur during Tick.
    ## 	This is used primarily to allow for warming up and simulated effects to a certain state.
    ##
    ## UPROPERTY()

  var bForcedInActive: bool
    ## This is set when any of our "don't tick me" timeout values have fired

  var bForceLODUpdateFromRenderer: bool
    ## If true, force an LOD update from the renderer.

  var cachedViewRelevanceFlags: TArray[FMaterialRelevance]
    ## The view relevance flags for each LODLevel.
    ## UPROPERTY(transient)

  var bIsViewRelevanceDirty: bool
    ## If true, the ViewRelevanceFlags are dirty and should be recached

  var replayClips: TArray[ptr UParticleSystemReplay]
    ## Array of replay clips for this particle system component.  These are serialized to disk.  You really should never add anything to this in the editor.  It's exposed so that you can delete clips if you need to, but be careful when doing so!
    ## UPROPERTY()

  var replayState: ParticleReplayState
    ## Current particle 'replay state'.  This setting controls whether we're currently simulating/rendering particles normally, or whether we should capture or playback particle replay data instead.

  var replayClipIDNumber: int32
    ## Clip ID number we're either playing back or capturing to, depending on the value of ReplayState.

  var replayFrameIndex: int32
    ## The current replay frame for playback

  var accumLODDistanceCheckTime: cfloat
    ## LOD updating...

  var spawnEvents: TArray[FParticleEventSpawnData]
    ## The Spawn events that occurred in this PSysComp.

  var deathEvents: TArray[FParticleEventDeathData]
    ## The Death events that occurred in this PSysComp.

  var collisionEvents: TArray[FParticleEventCollideData]
    ## The Collision events that occurred in this PSysComp.

  var burstEvents: TArray[FParticleEventBurstData]
    ## The Burst events that occurred in this PSysComp.

  var kismetEvents: TArray[FParticleEventKismetData]
    ## The Kismet events that occurred for this PSysComp.

  var customTimeDilation: cfloat
    ## Scales DeltaTime in UParticleSystemComponent::Tick(...)
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Particles)

  var emitterDelay: cfloat
    ## This is created at start up and then added to each emitter

  var onSystemFinished: FOnSystemFinished
    ## Called when the particle system is done
    ## UPROPERTY(BlueprintAssignable)

  var autoAttachParent: TWeakObjectPtr[USceneComponent]
    ## Component we automatically attach to when activated, if bAutoManageAttachment is true.
    ## If null during registration, we assign the existing AttachParent and defer attachment until we activate.
    ## @see bAutoManageAttachment
    ##
    ## UPROPERTY(VisibleInstanceOnly, BlueprintReadWrite, Category=Attachment, meta=(EditCondition="bAutoManageAttachment"))

  var autoAttachSocketName: FName
    ## Socket we automatically attach to on the AutoAttachParent, if bAutoManageAttachment is true.
    ## @see bAutoManageAttachment
    ##
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Attachment, meta=(EditCondition="bAutoManageAttachment"))

  var autoAttachLocationType: EAttachLocation
    ## Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
    ## @see bAutoManageAttachment, EAttachLocation::Type
    ##
    ## UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Attachment, meta=(EditCondition="bAutoManageAttachment"))

  proc setAutoAttachParams(parent: ptr USceneComponent; socketName: FName = NAME_None;
                           locationType: EAttachLocation = EAttachLocation.KeepRelativeOffset)
  proc getAsyncComponentToWorld(): var FTransform
  proc getAsyncInstanceParameters(): var TArray[FParticleSysParam]

  proc setBeamEndPoint(emitterIndex: int32; newEndPoint: FVector)
    ##	Beam-related script functions.
    ##
    ##
    ## 	Set the beam end point
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewEndPoint			The value to set it to
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setBeamSourcePoint(emitterIndex: int32; newSourcePoint: FVector;
                          sourceIndex: int32)
    ## 	Set the beam source point
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewSourcePoint		The value to set it to
    ## 	@param	SourceIndex			Which beam within the emitter to set it on
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setBeamSourceTangent(emitterIndex: int32; newTangentPoint: FVector;
                            sourceIndex: int32)
    ## 	Set the beam source tangent
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewTangentPoint		The value to set it to
    ## 	@param	SourceIndex			Which beam within the emitter to set it on
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setBeamSourceStrength(emitterIndex: int32; newSourceStrength: cfloat;
                             sourceIndex: int32)
    ## 	Set the beam source strength
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewSourceStrength	The value to set it to
    ## 	@param	SourceIndex			Which beam within the emitter to set it on
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setBeamTargetPoint(emitterIndex: int32; newTargetPoint: FVector;
                          targetIndex: int32)
    ## 	Set the beam target point
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewTargetPoint		The value to set it to
    ## 	@param	TargetIndex			Which beam within the emitter to set it on
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setBeamTargetTangent(emitterIndex: int32; newTangentPoint: FVector;
                            targetIndex: int32)
    ## 	Set the beam target tangent
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewTangentPoint		The value to set it to
    ## 	@param	TargetIndex			Which beam within the emitter to set it on
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setBeamTargetStrength(emitterIndex: int32; newTargetStrength: cfloat;
                             targetIndex: int32)
    ## 	Set the beam target strength
    ##
    ## 	@param	EmitterIndex		The index of the emitter to set it on
    ## 	@param	NewTargetStrength	The value to set it to
    ## 	@param	TargetIndex			Which beam within the emitter to set it on
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setEmitterEnable(emitterName: FName; bNewEnableState: bool)
    ## 	Enables/Disables a sub-emitter
    ##
    ## 	@param	EmitterName			The name of the sub-emitter to set it on
    ## 	@param	bNewEnableState		The value to set it to
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setFloatParameter(parameterName: FName; param: cfloat)
    ## Change a named float parameter
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setVectorParameter(parameterName: FName; param: FVector)
    ## 	Set a named vector instance parameter on this ParticleSystemComponent.
    ## 	Updates the parameter if it already exists, or creates a new entry if not.
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setColorParameter(parameterName: FName; param: FLinearColor)
    ## 	Set a named color instance parameter on this ParticleSystemComponent.
    ## 	Updates the parameter if it already exists, or creates a new entry if not.
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setActorParameter(parameterName: FName; param: ptr AActor)
    ## 	Set a named actor instance parameter on this ParticleSystemComponent.
    ## 	Updates the parameter if it already exists, or creates a new entry if not.
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc setMaterialParameter(parameterName: FName; param: ptr UMaterialInterface)
    ## 	Set a named material instance parameter on this ParticleSystemComponent.
    ## 	Updates the parameter if it already exists, or creates a new entry if not.
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc getFloatParameter(inName: FName; outFloat: var cfloat): bool
    ## 	Retrieve the Float parameter value for the given name.
    ##
    ## 	@param	InName		Name of the parameter
    ## 	@param	OutFloat	The value of the parameter found
    ##
    ## 	@return	true		Parameter was found - OutFloat is valid
    ## 			false		Parameter was not found - OutFloat is invalid

  proc getVectorParameter(inName: FName; outVector: var FVector): bool
    ## 	Retrieve the Vector parameter value for the given name.
    ##
    ## 	@param	InName		Name of the parameter
    ## 	@param	OutVector	The value of the parameter found
    ##
    ## 	@return	true		Parameter was found - OutVector is valid
    ## 			false		Parameter was not found - OutVector is invalid

  proc getAnyVectorParameter(inName: FName; outVector: var FVector): bool
    ## 	Retrieve the Vector parameter value for the given name...also looks for colors and floats and returns those
    ##
    ## 	@param	InName		Name of the parameter
    ## 	@param	OutVector	The value of the parameter found
    ##
    ## 	@return	true		Parameter was found - OutVector is valid
    ## 			false		Parameter was not found - OutVector is invalid

  proc getColorParameter(inName: FName; outColor: var FLinearColor): bool
    ## 	Retrieve the Color parameter value for the given name.
    ##
    ## 	@param	InName		Name of the parameter
    ## 	@param	OutColor	The value of the parameter found
    ##
    ## 	@return	true		Parameter was found - OutColor is valid
    ## 			false		Parameter was not found - OutColor is invalid

  proc getActorParameter(inName: FName; outActor: var ptr AActor): bool
    ## 	Retrieve the Actor parameter value for the given name.
    ##
    ## 	@param	InName		Name of the parameter
    ## 	@param	OutActor	The value of the parameter found
    ##
    ## 	@return	true		Parameter was found - OutActor is valid
    ## 			false		Parameter was not found - OutActor is invalid

  proc getMaterialParameter(inName: FName; outMaterial: var ptr UMaterialInterface): bool
    ## 	Retrieve the Material parameter value for the given name.
    ##
    ## 	@param	InName		Name of the parameter
    ## 	@param	OutMaterial	The value of the parameter found
    ##
    ## 	@return	true		Parameter was found - OutMaterial is valid
    ## 			false		Parameter was not found - OutMaterial is invalid

  proc clearParameter(parameterName: FName; parameterType: EParticleSysParamType = EParticleSysParamType(0))
    ## clears the specified parameter, returning it to the default value set in the template
    ## @param ParameterName name of parameter to remove
    ## @param ParameterType type of parameter to remove; if omitted or PSPT_None is specified, all parameters with the given name are removed

  proc setTemplate(newTemplate: ptr UParticleSystem)
    ## Change the ParticleSystem used by this ParticleSystemComponent
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc getNumActiveParticles(): int32 {.noSideEffect.}
    ## Get the current number of active particles in this system
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc getOwnedTrailEmitters(outTrailEmitters: var TrailEmitterArray;
                             inOwner: pointer; bSetOwner: bool = false)
    ## Fills the passed array with all trail emitters associated with a particular object.
    ## @param OutTrailEmitters	The array to fill with pointers to the trail emitters.
    ## @param InOwner			The object that triggered this trail. Can be NULL if no assosiation was set by the owner. Not to be confused with the result of GetOwner().
    ## @param bSetOwner			If true, all trail emitters will be set as owned by InOwner.

  proc beginTrails(inFirstSocketName: FName; inSecondSocketName: FName;
                   inWidthMode: ETrailWidthMode; inWidth: cfloat)
    ## Begins all trail emitters in this component.
    ##
    ## @param	InFirstSocketName	The name of the first socket for the trail.
    ## @param	InSecondSocketName	The name of the second socket for the trail.
    ## @param	InWidthMode			How the width value is applied to the trail.
    ## @param	InWidth				The width of the trail.
    ##
    ## UFUNCTION(BlueprintCallable, Category = "Effects|Particles|Trails")

  proc endTrails()
    ## Ends all trail emitters in this component.
    ##
    ## UFUNCTION(BlueprintCallable, Category = "Effects|Particles|Trails")

  proc setTrailSourceData(inFirstSocketName: FName; inSecondSocketName: FName;
                          inWidthMode: ETrailWidthMode; inWidth: cfloat)
    ## Sets the defining data for all trails in this component.
    ##
    ## @param	InFirstSocketName	The name of the first socket for the trail.
    ## @param	InSecondSocketName	The name of the second socket for the trail.
    ## @param	InWidthMode			How the width value is applied to the trail.
    ## @param	InWidth				The width of the trail.
    ##
    ## UFUNCTION(BlueprintCallable, Category = "Effects|Particles|Trails")

  var emitterInstances: TArray[ptr FParticleEmitterInstance]

  var FXSystem: ptr FFXSystemInterface

  var releaseResourcesFence: ptr FRenderCommandFence
    ## Command fence used to shut down properly

  proc forceAsyncWorkCompletion(behavior: EForceAsyncWorkCompletion) {.noSideEffect.}
    ## If there is async work outstanding, force it to be completed now *

  proc getCurrentDetailMode(): int32 {.noSideEffect.}
    ## Decide which detail mode should be applied to this particle system. If we have an editor
    ## override specified, use that. Otherwise use the global cached value

  proc computeTickComponent_Concurrent()
    ## Possibly parallel phase of TickComponent *

  proc finalizeTickComponent()
    ## After the possibly parallel phase of TickComponent, we fire events, etc *

  proc activateSystem(bFlagAsJustAttached: bool = false)
    ## Activate the system

  proc deactivateSystem()
    ## Deactivate the system

  proc particleLineCheck(hit: var FHitResult; sourceActor: ptr AActor; `end`: FVector;
                         start: FVector; halfExtent: FVector;
                         objectParams: FCollisionObjectQueryParams): bool
    ## Collision Handling...

  proc canTickInAnyThread(): bool
    ## return true if this psys can tick in any thread

  proc computeCanTickInAnyThread()
    ## Decide if this psys can tick in any thread, and set bIsElligibleForAsyncTick

  proc createNamedDynamicMaterialInstance(inName: FName; sourceMaterial: ptr UMaterialInterface = nil): ptr UMaterialInstanceDynamic
    ## Creates a Dynamic Material Instance for the specified named material override, optionally from the supplied material.
    ## @param Name - The slot name of the material to replace.  If invalid, the material is unchanged and NULL is returned.
    ##
    ## UFUNCTION(BlueprintCallable, Category = "Rendering|Material")

  proc getNamedMaterial(inName: FName): ptr UMaterialInterface {.noSideEffect.}
    ## Returns a named material. If this named material is not found, returns NULL.
    ## UFUNCTION(BlueprintCallable, Category = "Rendering|Material")

  proc getNamedMaterialIndex(inName: FName): int32 {.noSideEffect.}
    ## Returns the index into the EmitterMaterials array for this named. If there are no named material slots or this material is not found, INDEX_NONE is returned.
  proc getCurrentLODIndex(): int32 {.noSideEffect.}

  proc initParticles()
    ## If particles have not already been initialised (ie. EmitterInstances created) do it now.

  proc resetParticles(bEmptyInstances: bool = false)
    ## @todo document

  proc resetBurstLists()
    ## @todo document

  proc updateInstances(bEmptyInstances: bool = false)
    ## @todo document

  proc hasCompleted(): bool
    ## @todo document

  proc initializeSystem()
    ## @todo document

  proc conditionalCacheViewRelevanceFlags(newTemplate: ptr UParticleSystem = nil)
    ## 	Cache the view-relevance for each emitter at each LOD level if needed.
    ##
    ## 	@param	NewTemplate		The getNumMaterials* to use as the template.
    ## 							If NULL, use the currently set template.

  proc autoPopulateInstanceProperties()
    ## Auto-populate the instance parameters based on contained modules.

  proc reportEventSpawn(inEventName: FName; inEmitterTime: cfloat; inLocation: FVector;
                        inVelocity: FVector;
                        inEventData: TArray[ptr UParticleModuleEventSendToGame])
    ## Event reporting...
    ##
    ## 	Record a spawning event.
    ##
    ## 	@param	InEventName			The name of the event that fired.
    ## 	@param	InEmitterTime		The emitter time when the event fired.
    ## 	@param	InLocation			The location of the particle when the event fired.
    ## 	@param	InVelocity			The velocity of the particle when the event fired.
    ## @param  InEventData         Gamespecific event data payload

  proc reportEventDeath(inEventName: FName; inEmitterTime: cfloat; inLocation: FVector;
                        inVelocity: FVector;
                        inEventData: TArray[ptr UParticleModuleEventSendToGame];
                        inParticleTime: cfloat)
    ## 	Record a death event.
    ##
    ## 	@param	InEventName			The name of the event that fired.
    ## 	@param	InEmitterTime		The emitter time when the event fired.
    ## 	@param	InLocation			The location of the particle when the event fired.
    ## 	@param	InVelocity			The velocity of the particle when the event fired.
    ## @param  InEventData         Gamespecific event data payload
    ## 	@param	InParticleTime		The relative life of the particle when the event fired.

  proc reportEventCollision(inEventName: FName; inEmitterTime: cfloat;
                            inLocation: FVector; inDirection: FVector;
                            inVelocity: FVector; inEventData: TArray[ptr UParticleModuleEventSendToGame];
                            inParticleTime: cfloat; inNormal: FVector;
                            inTime: cfloat; inItem: int32; inBoneName: FName)
    ## 	Record a collision event.
    ##
    ## 	@param	InEventName		The name of the event that fired.
    ## 	@param	InEmitterTime	The emitter time when the event fired.
    ## 	@param	InLocation		The location of the particle when the event fired.
    ## 	@param	InDirection		The direction of the particle when the event fired.
    ## 	@param	InVelocity		The velocity of the particle when the event fired.
    ## @param  InEventData         Gamespecific event data payload
    ## 	@param	InParticleTime	The relative life of the particle when the event fired.
    ## 	@param	InNormal		Normal vector of the collision in coordinate system of the returner. Zero=none.
    ## 	@param	InTime			Time until hit, if line check.
    ## 	@param	InItem			Primitive data item which was hit, INDEX_NONE=none.
    ## 	@param	InBoneName		Name of bone we hit (for skeletal meshes).

  proc reportEventBurst(inEventName: FName; inEmitterTime: cfloat;
                        particleCount: int32; inLocation: FVector;
                        inEventData: TArray[ptr UParticleModuleEventSendToGame])
    ## 	Record a bursting event.
    ##
    ## 	@param	InEventName			The name of the event that fired.
    ## 	@param	InEmitterTime		The emitter time when the event fired.
    ## @param  InParticleCount     The number of particles spawned in the burst
    ## 	@param	InLocation			The location of the particle emitter when the event fired.

  proc generateParticleEvent(inEventName: FName; inEmitterTime: cfloat;
                             inLocation: FVector; inDirection: FVector;
                             inVelocity: FVector)
    ## 	Record a kismet event.
    ##
    ## 	@param	InEventName				The name of the event that fired.
    ## 	@param	InEmitterTime			The emitter time when the event fired.
    ## 	@param	InLocation				The location of the particle when the event fired.
    ## 	@param	InVelocity				The velocity of the particle when the event fired.
    ## 	@param	InNormal				Normal vector of the collision in coordinate system of the returner. Zero=none.
    ##
    ## UFUNCTION(BlueprintCallable, Category="Effects|Components|ParticleSystem")

  proc findReplayClipForIDNumber(inClipIDNumber: int32): ptr UParticleSystemReplay
    ## Finds the replay clip of the specified ID number
    ##
    ## @return Returns the replay clip or NULL if none

  proc killParticlesForced()
    ## @todo document

  proc setVectorRandParameter(parameterName: FName; param: FVector; paramLow: FVector)
    ## 	Set a named random vector instance parameter on this ParticleSystemComponent.
    ## 	Updates the parameter if it already exists, or creates a new entry if not.

  proc setFloatRandParameter(parameterName: FName; param: cfloat; paramLow: cfloat)
    ## 	Set a named random float instance parameter on this ParticleSystemComponent.
    ## 	Updates the parameter if it already exists, or creates a new entry if not.

  proc forceUpdateBounds()
    ## Force the component to update its bounding box.

  proc rewindEmitterInstances()
    ## @todo document

  proc determineLODLevelForLocation(effectLocation: FVector): int32
    ## This will determine which LOD to use based off the specific ParticleSystem passed in
    ## and the distance to where that PS is being displayed.
    ##
    ## @note:  This is distance based LOD not perf based.  Perf and distance are orthogonal concepts.

  proc setLODLevel(inLODLevel: int32)
    ## Set the LOD level of the particle system

  proc getLODLevel(): int32
    ## Get the LOD level of the particle system

  proc resetToDefaults()
    ## stops the emitter, unregisters the component, and resets the component's properties to the values of its template

# protected:

  proc updateLODInformation()
    ## @todo document

# static FDynamicEmitterDataBase* CreateDynamicDataFromReplay( FParticleEmitterInstance* EmitterInstance, const FDynamicEmitterReplayDataBase* EmitterReplayData, bool bSelected );
  ## Creates dynamic particle data for rendering the particle system this frame.  This function
  ## handle creation of dynamic data for regularly simulated particles, but also handles capture
  ## and playback of particle replay data.
  ##
  ## @return	Returns the dynamic data to render this frame

  proc createDynamicData(): ptr FParticleDynamicData

  proc orientZAxisTowardCamera()
    ## Orients the Z axis of the ParticleSystemComponent toward the camera while preserving the X axis direction

  proc clearDynamicData()
    ## Clears dynamic data on the rendering thread.

  proc updateDynamicData(proxy: ptr FParticleSystemSceneProxy)
    ## @todo document